webpackJsonp([0xd124a1595df5],{397:function(n,a){n.exports={data:{post:{id:"/Users/lugang/My Github/LG-Blog-Gatsby/content/posts/2018-03-11--webGL-learning-2/index.md absPath of file >>> MarkdownRemark",html:'<h2>Part 4</h2>\n<p>Welcome to 3D!!</p>\n<p>三维比二维多了一个深度信息(Z轴)，所以为了确定孤独的观测者的状态需要确定三个信息：1.观测的目标的坐标。2.观测者的坐标（视点）。3.上方向（比如你坐着不动头却乱扭，看到的场景也会变）。有了这三个矢量就可以创建出对应的视图矩阵，具体怎么算的我们暂且先不深入：</p>\n<iframe width="100%" height="430" src="//jsfiddle.net/todaylg/35br4q7m/19/embedded/result,js,css,html" allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>\n<p>在代码中我们将创建出来的视图矩阵直接与顶点坐标相乘，简单粗暴。WebGL默认视点(0,0,0)，观测点(0,0,-1),上方向（0,1,0）。</p>\n<p>其实视点是可以不需要移动的，比如视点后移一个单位，是完全等价于把被观察对象向前平移一个单位的，二者本质是一样的，都可以用矩阵来描述。</p>\n<p>而将旋转矩阵、平移矩阵、缩放矩阵和视图矩阵组合（就是矩阵相乘），比如先对三角形进行旋转变换，再怼旋转后的三角形进行与移动视点等效的变换，得到的就是在某个视点观察旋转后的三角形的图像了，而相乘后的矩阵就叫模型视图矩阵。</p>\n<h3>键盘控制移动视点</h3>\n<iframe width="100%" height="430" src="//jsfiddle.net/todaylg/35br4q7m/20/embedded/result,js,css,html" allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>\n<p>但是会发现转着转着会少一个角，这是因为我们没有指定可视范围造成的，即观察者的可视空间。常用的可视空间为正射投影（长方体）、金字塔(透视)投影（四棱锥）。</p>\n<h3>正射投影</h3>\n<p>首先可视空间都是由前后两个矩形表面来确定的，分别是近裁剪面和远裁剪面，前者的四个顶点为(right,top,-near),(-left,top,-near),(-left,-bottom,-near),(right,-bottom,-near)，后者的四个顶点为(right,top,-far),(-left,top,-far),(-left,-bottom,-far),(right,-bottom,-far).</p>\n<p>而正射投影是长方体的可视空间，那么其在xy轴上的坐标都是一样的，也就是需要确定的参数为：left,right,bottom,top,near,far。通过这些参数我们就可以计算得出正射投影矩阵（怎么算先不研究）,左右箭头修改near和far的值：</p>\n<iframe width="100%" height="430" src="//jsfiddle.net/todaylg/35br4q7m/21/embedded/result,js,css,html" allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>\n<p>知道了这个道理我们就可以修复之前缺角的情况了，无非就是把far调远一点,那顶点坐标再乘以一个投影矩阵呗：</p>\n<iframe width="100%" height="430" src="//jsfiddle.net/todaylg/35br4q7m/22/embedded/result,js,css,html" allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>\n<h3>透视投影</h3>\n<p>在正射投影中物体不管距离的远近是多大就多大，但是我们真实世界中很明显物体是近大远小的，这就是透视投影的可视空间了。</p>\n<p>透视投影需要的参数与正射投影不一样，需要确定的是可视空间顶面和底面的夹角fov、近裁剪面的宽高比aspect、near、far的位置四个参数，也是通过这几个参数可以计算出透视投影的矩阵（具体怎么算出来的先不研究）：</p>\n<iframe width="100%" height="430" src="//jsfiddle.net/todaylg/35br4q7m/23/embedded/result,js,css,html" allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>\n<p>将投影矩阵、视图矩阵、模型矩阵相乘可以得到模型试图投影矩阵。。。。上面的例子画了9个三角形，其实我们只需要画三个，剩下的通过变换即可得到:</p>\n<iframe width="100%" height="430" src="//jsfiddle.net/todaylg/35br4q7m/23/embedded/result,js,css,html" allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>\n<h3>前后关系</h3>\n<p>WebGL默认会按照缓冲区中的顺序绘制图形，后面的盖前面的，为了解决前后关系的问题，WebGL提供了隐藏面消除的功能：</p>\n<h3>gl.enable(cap)</h3>\n<hr>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cap</td>\n<td>指定需要开启的功能</td>\n</tr>\n<tr>\n<td></td>\n<td>gl.DEPTH_TEST(隐藏面消除)</td>\n</tr>\n<tr>\n<td></td>\n<td>gl.BLEND(混合)</td>\n</tr>\n<tr>\n<td></td>\n<td>gl.POLYGON\n_\nOFFSET\n_\nFILL(多边形位移)</td>\n</tr>\n</tbody>\n</table>\n<p>gl.clear()除了可以清楚颜色缓冲区，还可以清除深度缓冲区，深度缓冲区就是为了帮助WebGL进行隐藏面的消除，用来存储深度信息的。在绘制任意一帧之前都必须清除深度缓冲区，以消除绘制上一帧时留下的痕迹。</p>\n<p>我们只需要开启应场面消除，在绘制之前清空深度缓冲区，之后就不用在意放入缓冲区的顺序（倒着放入也无所谓）了：</p>\n<iframe width="100%" height="430" src="//jsfiddle.net/todaylg/35br4q7m/24/embedded/result,js,css,html" allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>\n<p>但是当Z轴的值完全一样的时候就会出现深度冲突的情况，因为两个表面过于接近，深度缓冲区的有限精度已经不能区分前后关系了，这时候再开启多边形偏移即可：</p>\n<h3>gl.polygonOffset(factor,units)</h3>\n<hr>\n<p>指定加到每个顶点会之后Z值上的偏移量，偏移量按照公式m x factor+ r x units计算(m表示顶点所在表面相对于观察者视线的角度，r表示硬件能够区分两个Z值之差的最小值)：</p>\n<iframe width="100%" height="430" src="//jsfiddle.net/todaylg/35br4q7m/25/embedded/result,js,css,html" allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>\n<p>先画了一个绿色的三角形，然后通过gl.polygonOffset()设置了多边形偏移参数，使得之后的绘制受到多边形偏移机制影响，再画一个黄色三角形，这样就避免了深度冲突了。</p>\n<h3>画个立方体</h3>\n<p>画立方体有很多种方法，比如一个面用两个三角形拼，6个面就是6x6=36个顶点，或者用gl.TRIANGLE_FAN来画，四个顶点就可以绘制一个四边形，就只需要4x6=24个顶点，一般我们都是使用gl.drawElements()替代gl.drawArrays()来进行绘制，能够避免重复定义顶点，保持顶点数量最小，立方体的话就是8个顶点，每个三角形与顶点列表的三个顶点相关联。</p>\n<h3>gl.drawElements(mode,count,type,offset)</h3>\n<hr>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>mode</td>\n<td>指定绘制方式</td>\n</tr>\n<tr>\n<td>count</td>\n<td>指定绘制顶点数</td>\n</tr>\n<tr>\n<td>type</td>\n<td>指定索引值数据类型</td>\n</tr>\n<tr>\n<td>offset</td>\n<td>指定索引数组中开始绘制的位置</td>\n</tr>\n</tbody>\n</table>\n<p>我们需要将顶点索引写入到缓冲区并绑定到gl.ELEMENT_ARRAY_BUFFER上：</p>\n<iframe width="100%" height="430" src="//jsfiddle.net/todaylg/35br4q7m/26/embedded/result,js,css,html" allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>\n<p>你会发现每个顶点的颜色影响到了三个面，我们只要单独把顶点坐标拎出来即可：</p>\n<iframe width="100%" height="430" src="//jsfiddle.net/todaylg/35br4q7m/27/embedded/result,js,css,html" allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>\n<h2>Part 5</h2>\n<p>OF光呢！！！？？？</p>\n<p>常见的光为以下三种：</p>\n<p>1.平行光。可以用一个方向和一个颜色来定义。</p>\n<p>2.点光源光。可以用一个坐标和颜色来定义。</p>\n<p>3.环境光。只需要颜色即可。</p>\n<p>反射类型分为：</p>\n<p>1.漫反射。漫反射是针对于平行光或者点光源而言的，反射光的颜色取决于入射光的颜色x表面基底色xcos(angle)(angle为入射光与表面形成的入射角，可以根据光线和表面的方向计算得出)</p>\n<p>2.环境反射。环境反射是针对于环境光而言的，反射光的方向可以认为就是入射光的反方向，即取决于入射光颜色x表面基底色。</p>\n<p>如果二者同时存在就直接相加。</p>\n<iframe width="100%" height="420" src="//jsfiddle.net/todaylg/35br4q7m/28/embedded/result,js,css,html" allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>\n<p>再加上环境光：</p>\n<iframe width="100%" height="420" src="//jsfiddle.net/todaylg/35br4q7m/29/embedded/result,js,css,html" allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>\n<p>要是加上变换的话情况就更复杂了，平移还好，不会改变平面的法向量，但是旋转就会了，这时候强大的逆转置矩阵就有声音了，怎么计算经过变换（乘以模型矩阵）后的法向量呢？只要将变换之前的法向量乘以模型矩阵的逆转置矩阵即可。首先逆矩阵是什么，矩阵乘以逆矩阵为单位矩阵，转置就是行列进行调换。（果然全是数学😂。。想放弃治疗了。。😢）</p>\n<iframe width="100%" height="420" src="//jsfiddle.net/todaylg/35br4q7m/30/embedded/result,js,css,html" allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>\n<p>换成点光源光（需要光源的世界坐标了）：</p>\n<p>逐顶点：</p>\n<iframe width="100%" height="420" src="//jsfiddle.net/todaylg/35br4q7m/31/embedded/result,js,css,html" allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>\n<p>逐片元：</p>\n<iframe width="100%" height="420" src="//jsfiddle.net/todaylg/35br4q7m/32/embedded/result,js,css,html" allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>\n<p>动起来：</p>\n<p>环境光：</p>\n<iframe width="100%" height="420" src="//jsfiddle.net/todaylg/35br4q7m/33/embedded/result,js,css,html" allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>\n<p>点光源光：</p>\n<iframe width="100%" height="420" src="//jsfiddle.net/todaylg/35br4q7m/34/embedded/result,js,css,html" allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>\n<h3>initShaders()</h3>\n<p>其作用总的来说就是编译GLSL ES代码，创建和初始化着色器（顶点和片元）：</p>\n<p>1.创建着色器对象（gl.createShader()）</p>\n<p>2.向着色器对象中填充着色器程序的源代码（gl.shaderSource()）</p>\n<p>3.编译着色器（gl.compileShader()）</p>\n<p>4.创建程序对象（gl.createProgram()）</p>\n<p>5.为程序对象分配着色器（gl.attachShader()）</p>\n<p>6.连接程序对象（gl.linkProgram()）</p>\n<p>7.使用程序对象（gl.useProgram()）</p>\n<p>这里的着色器对象用于管理一个顶点着色器或者一个片元着色器，每一个着色器都有一个着色器对象。程序对象是管理着色器对象的容器，在WebGL中一个程序对象必须包含一个顶点着色器和一个片元着色器。所以一般都是两个着色器（顶点加片元）对象和一个程序对象。</p>\n<h3>1.创建着色器对象（gl.createShader()）</h3>\n<p>所有的着色器对象都必须通过调用gl.createShader()来创建。</p>\n<h3>gl.createShader(type)</h3>\n<hr>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>参数取值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>type</td>\n<td>gl.VERTEX\n_\nSHADER(顶点着色器)或者gl.FRAGMENT\n_\nSHADER(片元着色器)</td>\n</tr>\n</tbody>\n</table>\n<p>有create必有delete，所以gl.deleteShader()函数则是用来删除（不是马上删除，会等到程序对象不再使用该着色器后再删除）着色器对象的。</p>\n<h3>2.向着色器对象中填充着色器程序的源代码（gl.shaderSource()）</h3>\n<h3>gl.shaderSource(shader, source)</h3>\n<hr>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>参数取值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>shader</td>\n<td>指定需要传入代码的着色器对象</td>\n</tr>\n<tr>\n<td>source</td>\n<td>指定字符串形式的代码</td>\n</tr>\n</tbody>\n</table>\n<h3>3.编译着色器（gl.compileShader()）</h3>\n<p>传入源代码之后还需要编译之后才能使用（所以要是更新了源代码想要效果也跟着更新就还需要重新编译）</p>\n<h3>gl.compileShader(shader)</h3>\n<hr>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>参数取值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>shader</td>\n<td>待编译的着色器</td>\n</tr>\n</tbody>\n</table>\n<p>debug的话可以调用gl.getShaderParameter()函数来检查着色器的状态。</p>\n<h3>gl.getShaderParameter(shader, pname)</h3>\n<hr>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>参数取值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>shader</td>\n<td>指定待获取参数的着色器</td>\n</tr>\n<tr>\n<td>shader</td>\n<td>指定待获取参数的类型</td>\n</tr>\n<tr>\n<td></td>\n<td>gl.SHADER_TYPE</td>\n</tr>\n<tr>\n<td></td>\n<td>gl.DELETE_STATUS</td>\n</tr>\n<tr>\n<td></td>\n<td>gl.COMPILE_STATUS</td>\n</tr>\n</tbody>\n</table>\n<p>要是直接编译失败gl.getShaderParameter会返回false，我们可以通过getShaderInfoLog（shader）来查看信息日志</p>\n<h3>4.创建程序对象（gl.createProgram()）</h3>\n<p>之前使用的gl.getAttribLocation和gl.getUniformLocation函数的第一个参数就是这个程序对象。</p>\n<h3>gl.createProgram()</h3>\n<hr>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>参数取值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>无</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>一旦程序对象被创建之后，需要向程序附上两个着色器：</p>\n<h3>5.为程序对象分配着色器（gl.attachShader()）</h3>\n<h3>gl.attachShader(program, shader)</h3>\n<hr>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>参数取值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>program</td>\n<td>指定程序对象</td>\n</tr>\n<tr>\n<td>shader</td>\n<td>指定着色器对象</td>\n</tr>\n</tbody>\n</table>\n<p>同样的gl.detachShader函数用来解除分配给程序对象的着色器。</p>\n<h3>6.连接程序对象（gl.linkProgram()）</h3>\n<p>在为程序对象分配了两个着色器对象后，还需要将顶点着色器和片元着色器连接起来。</p>\n<h3>gl.linkProgram(program)</h3>\n<hr>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>参数取值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>program</td>\n<td>连接指定程序对象中的着色器</td>\n</tr>\n</tbody>\n</table>\n<p>程序对象进行连接操作，目的是保证顶点着色器和片元着色器的varying变量同名同类型且一一对应；顶点着色器对每个varying变量赋了值；顶点着色器和片元着色器中的同名uniform变量也是同类型的（无需一一对应）；着色器中的attribute、uniform、varying变量的个数没有超过着色器的上限。</p>\n<p>查看是否连接成功可以通过调用gl.getProgramPara-meters()函数来实现，如果连接失败了也可以通过调用gl.getProgramInfoLog从信息日志中获取连接出错信息。</p>\n<h3>7.使用程序对象（gl.useProgram()）</h3>\n<p>最后就是通过调用gl.useProgram()来告知WebGL系统绘制时使用哪个程序对象</p>\n<h3>gl.useProgram(program)</h3>\n<hr>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>参数取值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>program</td>\n<td>指定待使用的程序对象</td>\n</tr>\n</tbody>\n</table>\n<p>所以initShaders()函数的内部流程也是这几步。</p>\n<h3>放弃治疗了放弃治疗了。。。。</h3>\n<h2>实例分析</h2>\n<p>这是CodePen上一个大佬的WebGL粒子效果的例子，瞅了瞅发现好像不是那么复杂，决定好好研究下代码，先上个改巴改巴后的最终效果（jsfiddle效果直接出不来。。。所以换成了codepen）：</p>\n<iframe height=\'400\' scrolling=\'no\' title=\'WebGL\\\\_Learning\\\\_Day1\' src=\'//codepen.io/todaylg/embed/GOwdWM/?height=265&theme-id=0&default-tab=js,result&embed-version=2\' frameborder=\'no\' allowtransparency=\'true\' allowfullscreen=\'true\' style=\'width: 100%;\'>See the Pen <a href=\'https://codepen.io/todaylg/pen/GOwdWM/\'>WebGL\\\\_Learning\\\\_Day1</a> by todaylg (<a href=\'https://codepen.io/todaylg\'>@todaylg</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>\n<p>代码分析：</p>\n<p>首先看到html，其中定义了简单的顶点着色器和片元着色器代码：</p>\n<p>顶点着色器：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">attribute vec3 vertexPosition;\nuniform mat4 modelViewMatrix;\nuniform mat4 perspectiveMatrix;\n\nvoid main(void) {\n    gl_Position = perspectiveMatrix * modelViewMatrix * vec4(  vertexPosition, 1.0);\n}</code></pre>\n      </div>\n<p>片元着色器：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">#ifdef GL_ES\nprecision highp float;\n#endif\nvoid main(void) {\n    gl_FragColor = vec4(0.2, 0.3, 0.4, 1.0);\n    //gl_FragColor = vec4(0.4, 0.2, 0.3, 1.0);\n}</code></pre>\n      </div>\n<p>顶点着色器程序创建了模型矩阵、投影矩阵、3维顶点坐标，为了统一计算把3维顶点坐标换为了四维参与运算得到最终的位置。片元着色器程序则是直接简单粗暴的写死了粒子的颜色。</p>\n<p>转到js：</p>\n<p>loadScene()函数相当于做了initSharder()函数的活，完成了程序对象的创建和使用，之后开启混合模式并且对随机变量进行初始化、金字塔投影矩阵的初始化、模型矩阵的初始化。</p>\n<p>setup()中初始化的rad代表粒子旋转轨迹圆的半径，theta相当于angle，velTheta相当于变换的幅度（角度变换），freq和boldRate不用管，没有用到，randomPosX/Y是整个屏幕内的随机坐标。</p>\n<p>核心方法在draw0/draw1/draw2方法，这几个方法会在一定间隔时间以内循环依次调用。</p>\n<h3>draw0：</h3>\n<hr>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">draw0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\n  <span class="token keyword">var</span> i<span class="token punctuation">,</span> n <span class="token operator">=</span> vertices<span class="token punctuation">.</span>length<span class="token punctuation">,</span> p<span class="token punctuation">,</span> bp<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> px<span class="token punctuation">,</span> py<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> pTheta<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> rad<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> num<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> targetX<span class="token punctuation">,</span> targetY<span class="token punctuation">;</span>\n\n  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numLines <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//因为是线，粒子数量乘以2，然后将多复制出来的一份粒子坐标略做偏移，之后相连，效果就出来了？？？？？并不对i+=2才是导致numLines * 2的原因</span>\n    count <span class="token operator">+=</span> <span class="token number">.3</span><span class="token punctuation">;</span>\n    bp <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span>\n\n    vertices<span class="token punctuation">[</span>bp<span class="token punctuation">]</span> <span class="token operator">=</span> vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//确保线起始点一致</span>\n\n    num <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    targetX <span class="token operator">=</span> randomTargetXArr<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//init时的随机位置</span>\n    targetY <span class="token operator">=</span> randomTargetYArr<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n\n    px <span class="token operator">=</span> vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    px <span class="token operator">+=</span> <span class="token punctuation">(</span>targetX <span class="token operator">-</span> px<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">.04</span> <span class="token operator">+</span> <span class="token number">.6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//相较于上一时刻的位置略做偏移</span>\n    vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> px<span class="token punctuation">;</span><span class="token comment">//所以虽然是线但是两个点的坐标相差不大。</span>\n\n\n    <span class="token comment">//py = (Math.sin(cn) + 1) * .2 * (Math.random() * .5 - .25);</span>\n    py <span class="token operator">=</span> vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    py <span class="token operator">+=</span> <span class="token punctuation">(</span>targetY <span class="token operator">-</span> py<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">.04</span> <span class="token operator">+</span> <span class="token number">.06</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//位置略做偏移</span>\n    vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> py<span class="token punctuation">;</span>\n\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>这里需要注意因为缓冲区里面只存放顶点的坐标信息，而不带大小、透明度等其他信息，所以gl.drawArray的时候要是画点（即第一个参数传入gl.POINTS），那么粒子亮度很低（因为太小了），视觉效果不好。这里采用的办法是画线，而每次绘制时先同步线的起终点，之后对线的终点做微小的位移，draw0/1/2都是如此。</p>\n<p>draw0最简单，就是把各个坐标朝最开始全屏随机分配的坐标归位回去，也就是回到分散状态的动画效果。</p>\n<h3>draw1</h3>\n<hr>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">draw1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\n  <span class="token keyword">var</span> i<span class="token punctuation">,</span> n <span class="token operator">=</span> vertices<span class="token punctuation">.</span>length<span class="token punctuation">,</span> p<span class="token punctuation">,</span> bp<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> px<span class="token punctuation">,</span> py<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> pTheta<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> rad<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> num<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> targetX<span class="token punctuation">,</span> targetY<span class="token punctuation">;</span>\n\n  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numLines <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    count <span class="token operator">+=</span> <span class="token number">.3</span><span class="token punctuation">;</span>\n    bp <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span>\n\n    vertices<span class="token punctuation">[</span>bp<span class="token punctuation">]</span> <span class="token operator">=</span> vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n    num <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    pTheta <span class="token operator">=</span> thetaArr<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    rad <span class="token operator">=</span> velRadArr<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n    pTheta <span class="token operator">+=</span> velThetaArr<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    thetaArr<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> pTheta<span class="token punctuation">;</span>\n\n    targetX <span class="token operator">=</span> rad <span class="token operator">*</span><span class="token number">2</span><span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span>pTheta<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    targetY <span class="token operator">=</span> rad <span class="token operator">*</span><span class="token number">2</span><span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span>pTheta<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    px <span class="token operator">=</span> vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    px <span class="token operator">+=</span> <span class="token punctuation">(</span>targetX <span class="token operator">-</span> px<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">.1</span> <span class="token operator">+</span> <span class="token number">.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//朝方向缓动</span>\n    vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> px<span class="token punctuation">;</span>\n\n    <span class="token comment">//py = (Math.sin(cn) + 1) * .2 * (Math.random() * .5 - .25);</span>\n    py <span class="token operator">=</span> vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    py <span class="token operator">+=</span> <span class="token punctuation">(</span>targetY <span class="token operator">-</span> py<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">.1</span> <span class="token operator">+</span> <span class="token number">.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> py<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>draw1则是朝屏幕中心（WebGL的原点）以rad为半径，每次变换velThetaArr角度的圆为轨迹运动。</p>\n<h3>draw2</h3>\n<hr>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">draw2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  cn <span class="token operator">+=</span> <span class="token number">.1</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">var</span> i<span class="token punctuation">,</span> n <span class="token operator">=</span> vertices<span class="token punctuation">.</span>length<span class="token punctuation">,</span> p<span class="token punctuation">,</span> bp<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> px<span class="token punctuation">,</span> py<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> pTheta<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> rad<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> num<span class="token punctuation">;</span>\n\n  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numLines <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    count <span class="token operator">+=</span> <span class="token number">.3</span><span class="token punctuation">;</span>\n    bp <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span>\n    <span class="token comment">// copy old positions</span>\n\n    vertices<span class="token punctuation">[</span>bp<span class="token punctuation">]</span> <span class="token operator">=</span> vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n    num <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    pTheta <span class="token operator">=</span> thetaArr<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n    rad <span class="token operator">=</span> velRadArr<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// + Math.cos(pTheta + i * freqArr[i]) *  boldRateArr[num];</span>\n\n    pTheta <span class="token operator">+=</span> velThetaArr<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    thetaArr<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> pTheta<span class="token punctuation">;</span>\n\n    px <span class="token operator">=</span> vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    px <span class="token operator">+=</span> rad <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span>pTheta<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">;</span><span class="token comment">//cos、sin都会有负值</span>\n    vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> px<span class="token punctuation">;</span>\n\n\n    <span class="token comment">//py = (Math.sin(cn) + 1) * .2 * (Math.random() * .5 - .25);</span>\n    py <span class="token operator">=</span> vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n    py <span class="token operator">+=</span> rad <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span>pTheta<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">;</span>\n    <span class="token comment">//p *= ( Math.random() -.5);</span>\n    vertices<span class="token punctuation">[</span>bp <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> py<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>draw2的角度变化和draw1是一致的，但是粒子旋转的轨迹圆不在是以屏幕中心为统一坐标，而是分散开来了。</p>\n<p>最后通过timer和draw：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  drawType <span class="token operator">=</span> <span class="token punctuation">(</span>drawType <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">;</span>\n\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">,</span> <span class="token number">1500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">switch</span> <span class="token punctuation">(</span>drawType<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span>\n      <span class="token function">draw1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">break</span><span class="token punctuation">;</span>\n    <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>\n      <span class="token function">draw2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">break</span><span class="token punctuation">;</span>\n    <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>\n      <span class="token function">draw0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">break</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>在三者之间循环依次调用，效果就完成啦。</p>\n<iframe height=\'400\' scrolling=\'no\' title=\'WebGL\\\\_Learning\\\\_Day1\' src=\'//codepen.io/todaylg/embed/GOwdWM/?height=265&theme-id=0&default-tab=result&embed-version=2\' frameborder=\'no\' allowtransparency=\'true\' allowfullscreen=\'true\' style=\'width: 100%;\'>See the Pen <a href=\'https://codepen.io/todaylg/pen/GOwdWM/\'>WebGL\\\\_Learning\\\\_Day1</a> by todaylg (<a href=\'https://codepen.io/todaylg\'>@todaylg</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>',
fields:{slug:"/webGL-learning-2/",prefix:"2018-03-11"},frontmatter:{title:"初探WebGL(二)",author:"todaylg",category:"大结",cover:{childImageSharp:{resize:{src:"/LG-Blog-Gatsby/static/test0-001f0e2d7f4ddf714c80fd94baee6c4e-ada8c.jpg"}}}}},authornote:{id:"/Users/lugang/My Github/LG-Blog-Gatsby/content/parts/author.md absPath of file >>> MarkdownRemark",html:"<p><strong>todaylg</strong> </p>"},site:{siteMetadata:{facebook:{appId:""}}}},pathContext:{slug:"/webGL-learning-2/",prev:{id:"/Users/lugang/My Github/LG-Blog-Gatsby/content/posts/2018-03-10--webGL-learning-1/index.md absPath of file >>> MarkdownRemark",fields:{slug:"/webGL-learning-1/",prefix:"2018-03-10"},frontmatter:{title:"初探WebGL(一)",category:"大结"}},next:{id:"/Users/lugang/My Github/LG-Blog-Gatsby/content/posts/2018-06-25--hello-world/index.md absPath of file >>> MarkdownRemark",fields:{slug:"/hello-world/",prefix:"2018-06-25"},frontmatter:{title:"Hello World!!",category:"废话集"}}}}}});
//# sourceMappingURL=path---web-gl-learning-2-95e2399e192ed3c1e15b.js.map